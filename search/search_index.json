{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>SQLAlchemy-file is a SQLAlchemy extension for attaching files to SQLAlchemy model and uploading them to various storage such as Local Storage, Amazon S3, Rackspace CloudFiles, Google Storage and others using Apache Libcloud.</p> <p> </p> <p>The key features are:</p> <ul> <li>Multiple Storage : Use Object Storage API provided by Apache Libcloud to   store files. Therefore, you can store your files on Local Storage, Amazon S3, Google Cloud Storage, MinIO etc, and   easily switch between them. For a full list of supported providers   visit supported providers page from Apache   Libcloud documentation.</li> <li>Validator :  Provide an interface for validating each files before saving them.</li> <li>Size Validator : Built-in validator for file maximum <code>size</code> validation.</li> <li>Content-Type Validator : Built-in validator for file <code>mimetype</code> restrictions.</li> <li>Image Validator : Built-in validator for image <code>mimetype</code>, <code>width</code>, <code>height</code> and <code>ratio</code> validation.</li> <li>Processor : Provide an interface to easily save multiple transformation of the original files.</li> <li>ThumbnailGenerator : Built-in processor to auto generate thumbnail</li> <li>Multiple Files : You can attach multiple files directly to a Model.</li> <li>Session awareness : Whenever an object is deleted or a rollback is performed the files uploaded during the unit of   work or attached to the deleted objects are automatically deleted.</li> <li>Meant for Evolution : Change the storage provider anytime you want, old data will continue to work</li> <li>SQLModel Support: Tested with SQLModel</li> </ul> <p>Documentation: https://jowilf.github.io/sqlalchemy-file</p> <p>Source Code: https://github.com/jowilf/sqlalchemy-file</p>"},{"location":"#requirements","title":"Requirements","text":"<p>A recent and currently supported version of Python (right now, Python supports versions 3.7 and above).</p> <p>As SQLAlchemy-file is based on Apache Libcloud and SQLAlchemy, it requires them. They will be automatically installed when you install SQLAlchemy-file.</p>"},{"location":"#installation","title":"Installation","text":""},{"location":"#pip","title":"PIP","text":"<pre><code>$ pip install sqlalchemy-file\n</code></pre>"},{"location":"#poetry","title":"Poetry","text":"<pre><code>$ poetry add sqlalchemy-file\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Attaching files to models is as simple as declaring a field on the model itself</p> <pre><code>import os\n\nfrom libcloud.storage.drivers.local import LocalStorageDriver\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy_file import File, FileField\nfrom sqlalchemy_file.storage import StorageManager\n\nBase = declarative_base()\n\n\n# Define your model\nclass Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(FileField)\n\n\n# Configure Storage\nos.makedirs(\"./upload_dir/attachment\", 0o777, exist_ok=True)\ncontainer = LocalStorageDriver(\"./upload_dir\").get_container(\"attachment\")\nStorageManager.add_storage(\"default\", container)\n\n# Save your model\nengine = create_engine(\n    \"sqlite:///example.db\", connect_args={\"check_same_thread\": False}\n)\nBase.metadata.create_all(engine)\n\nwith Session(engine) as session, open(\"./example.txt\", \"rb\") as local_file:\n    # from an opened local file\n    session.add(Attachment(name=\"attachment1\", content=local_file))\n\n    # from bytes\n    session.add(Attachment(name=\"attachment2\", content=b\"Hello world\"))\n\n    # from string\n    session.add(Attachment(name=\"attachment3\", content=\"Hello world\"))\n\n    # from a File object with custom filename and content_type\n    file = File(content=\"Hello World\", filename=\"hello.txt\", content_type=\"text/plain\")\n    session.add(Attachment(name=\"attachment4\", content=file))\n\n    # from a File object specifying a content path\n    session.add(Attachment(name=\"attachment5\", content=File(content_path=\"./example.txt\")))\n\n    session.commit()\n</code></pre>"},{"location":"#related-projects-and-inspirations","title":"Related projects and inspirations","text":"<ul> <li>filedepot:  When I was looking for a library like this, depot was the best I saw. This project inspired SQLAlchemy-file extensively and some features are implemented the same.</li> <li>sqlalchemy-media:  Another attachment extension for SqlAlchemy to manage assets which are associated with database models</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#060-2023-10-07","title":"[0.6.0] - 2023-10-07","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Add option to upload files by path in #87   by @adscib</li> </ul>"},{"location":"changelog/#050-2023-07-21","title":"[0.5.0] - 2023-07-21","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix #79: Remove the files generated by processors after an   update or a delete   in #84</li> <li>Fix #78: Add content-type to <code>extra</code> data in ThumbnailGenerator   by @wojtha   in #80</li> </ul>"},{"location":"changelog/#internals","title":"Internals","text":"<ul> <li>Add additional Ruff rules &amp; update dependencies in #77</li> </ul>"},{"location":"changelog/#040-2023-03-02","title":"[0.4.0] - 2023-03-02","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Add SQLAlchemy 2 support</li> </ul>"},{"location":"changelog/#030-2023-01-09","title":"[0.3.0] - 2023-01-09","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Support for apache-libloud 3.7</li> </ul>"},{"location":"changelog/#020-2022-11-28","title":"[0.2.0] - 2022-11-28","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Allow storage extra &amp; headers attributes in #18</li> </ul>"},{"location":"changelog/#015-2022-10-15","title":"[0.1.5] - 2022-10-15","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Add py.typed(PEP 561) in #14</li> </ul>"},{"location":"changelog/#014-2022-08-30","title":"[0.1.4] - 2022-08-30","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Add <code>upload_storage</code> to the default information saved into the database. Before, <code>upload_storage</code> can be extracted   from <code>path</code> attribute. Now you can access directly with <code>file['upload_storage']</code> in #11</li> <li>Accept additional metadata from <code>File</code> object in #11</li> <li>Add section Upload File to the   documentation</li> </ul>"},{"location":"changelog/#013-2022-08-23","title":"[0.1.3] - 2022-08-23","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Add <code>thumbnail_size</code> property to ImageField in #9</li> </ul>"},{"location":"changelog/#012-2022-08-11","title":"[0.1.2] - 2022-08-11","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Add CHANGELOG.md</li> </ul>"},{"location":"api/exceptions/","title":"Exceptions","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for ValidationError Parameters:     key: Current Column key     msg: Validation error message.</p> Source code in <code>sqlalchemy_file/exceptions.py</code> <pre><code>class ValidationError(Exception):\n    \"\"\"Base class for ValidationError\n    Parameters:\n        key: Current Column key\n        msg: Validation error message.\n    \"\"\"\n\n    def __init__(self, key: str, msg: str):  # pragma: no cover\n        super().__init__(f\"{key}: {msg}\")\n        self.key = key\n        self.msg = msg\n</code></pre> <p>             Bases: <code>ValidationError</code></p> Source code in <code>sqlalchemy_file/exceptions.py</code> <pre><code>class SizeValidationError(ValidationError):\n    pass\n</code></pre> <p>             Bases: <code>ValidationError</code></p> Source code in <code>sqlalchemy_file/exceptions.py</code> <pre><code>class ContentTypeValidationError(ValidationError):\n    pass\n</code></pre> <p>             Bases: <code>ValidationError</code></p> Source code in <code>sqlalchemy_file/exceptions.py</code> <pre><code>class InvalidImageError(ValidationError):\n    pass\n</code></pre> <p>             Bases: <code>ValidationError</code></p> Source code in <code>sqlalchemy_file/exceptions.py</code> <pre><code>class DimensionValidationError(ValidationError):\n    pass\n</code></pre> <p>             Bases: <code>ValidationError</code></p> Source code in <code>sqlalchemy_file/exceptions.py</code> <pre><code>class AspectRatioValidationError(ValidationError):\n    pass\n</code></pre>"},{"location":"api/file/","title":"File","text":"<p>             Bases: <code>Dict[str, Any]</code></p> <p>Base class for file object.</p> <p>It keeps information on a content related to a specific storage. It is a specialized dictionary that provides also attribute style access, the dictionary parent permits easy encoding/decoding to JSON.</p> Source code in <code>sqlalchemy_file/base.py</code> <pre><code>class BaseFile(typing.Dict[str, Any]):\n    \"\"\"Base class for file object.\n\n    It keeps information on a content related to a specific storage.\n    It is a specialized dictionary that provides also attribute style access,\n    the dictionary parent permits easy encoding/decoding to JSON.\n\n    \"\"\"\n\n    def __getitem__(self, key: str) -&gt; Any:\n        return dict.__getitem__(self, key)\n\n    def __getattr__(self, name: str) -&gt; Any:\n        try:\n            return self[name]\n        except KeyError:\n            raise AttributeError(name)\n\n    def __setitem__(self, key: str, value: Any) -&gt; None:\n        if getattr(self, \"_frozen\", False):\n            raise TypeError(\"Already saved files are immutable\")\n        return dict.__setitem__(self, key, value)\n\n    __setattr__ = __setitem__\n\n    def __delattr__(self, name: str) -&gt; None:\n        if getattr(self, \"_frozen\", False):\n            raise TypeError(\"Already saved files are immutable\")\n\n        try:\n            del self[name]\n        except KeyError:\n            raise AttributeError(name)\n\n    def __delitem__(self, key: str) -&gt; None:\n        if object.__getattribute__(self, \"_frozen\"):\n            raise TypeError(\"Already saved files are immutable\")\n        dict.__delitem__(self, key)\n\n    def _freeze(self) -&gt; None:\n        object.__setattr__(self, \"_frozen\", True)\n\n    def _thaw(self) -&gt; None:\n        object.__setattr__(self, \"_frozen\", False)\n</code></pre> <p>             Bases: <code>BaseFile</code></p> <p>Takes a file as content and uploads it to the appropriate storage according to the attached Column and file information into the database as JSON.</p> <p>Default attributes provided for all <code>File</code> include:</p> <p>Attributes:</p> Name Type Description <code>filename</code> <code>str</code> <p>This is the name of the uploaded file</p> <code>file_id</code> <code>str</code> <p>This is the generated UUID for the uploaded file</p> <code>upload_storage</code> <code>str</code> <p>Name of the storage used to save the uploaded file</p> <code>path</code> <code>str</code> <p>This is a  combination of <code>upload_storage</code> and <code>file_id</code> separated by             <code>/</code>. This will be use later to retrieve the file</p> <code>content_type</code> <code>str</code> <p>This is the content type of the uploaded file</p> <code>uploaded_at</code> <code>datetime</code> <p>This is the upload date in ISO format</p> <code>url</code> <code>str</code> <p>CDN url of the uploaded file</p> <code>file</code> <code>StoredFile</code> <p>Only available for saved content, internally call           StorageManager.get_file()           on path and return an instance of <code>StoredFile</code></p> Source code in <code>sqlalchemy_file/file.py</code> <pre><code>class File(BaseFile):\n    \"\"\"Takes a file as content and uploads it to the appropriate storage\n    according to the attached Column and file information into the\n    database as JSON.\n\n    Default attributes provided for all ``File`` include:\n\n    Attributes:\n        filename (str):  This is the name of the uploaded file\n        file_id:   This is the generated UUID for the uploaded file\n        upload_storage:   Name of the storage used to save the uploaded file\n        path:            This is a  combination of `upload_storage` and `file_id` separated by\n                        `/`. This will be use later to retrieve the file\n        content_type:   This is the content type of the uploaded file\n        uploaded_at (datetime):    This is the upload date in ISO format\n        url (str):            CDN url of the uploaded file\n        file:           Only available for saved content, internally call\n                      [StorageManager.get_file()][sqlalchemy_file.storage.StorageManager.get_file]\n                      on path and return an instance of `StoredFile`\n    \"\"\"\n\n    def __init__(\n        self,\n        content: Any = None,\n        filename: Optional[str] = None,\n        content_type: Optional[str] = None,\n        content_path: Optional[str] = None,\n        **kwargs: Dict[str, Any],\n    ) -&gt; None:\n        if content is None and content_path is None:\n            raise ValueError(\"Either content or content_path must be specified\")\n        super().__init__(**kwargs)\n        if isinstance(content, dict):\n            object.__setattr__(self, \"original_content\", None)\n            object.__setattr__(self, \"saved\", True)\n            self.update(content)\n            self._freeze()\n        else:\n            self.content_path = content_path\n            if content_path is not None:\n                self.original_content = None\n                filename = filename or os.path.basename(content_path)\n                size = os.path.getsize(content_path)\n            else:\n                self.original_content = get_content_from_file_obj(content)\n                filename = filename or get_filename_from_fileob(content)\n                size = get_content_size_from_fileobj(self.original_content)\n            content_type = content_type or get_content_type_from_fileobj(\n                content, filename\n            )\n            self.update(\n                {\n                    \"filename\": filename,\n                    \"content_type\": content_type,\n                    \"size\": size,\n                    \"files\": [],\n                }\n            )\n            self._thaw()\n\n    def apply_validators(self, validators: List[Validator], key: str = \"\") -&gt; None:\n        \"\"\"Apply validators to current file.\"\"\"\n        for validator in validators:\n            validator.process(self, key)\n\n    def apply_processors(\n        self,\n        processors: List[Processor],\n        upload_storage: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Apply processors to current file.\"\"\"\n        for processor in processors:\n            processor.process(self, upload_storage)\n        self._freeze()\n\n    def save_to_storage(self, upload_storage: Optional[str] = None) -&gt; None:\n        \"\"\"Save current file into provided `upload_storage`.\"\"\"\n        extra = self.get(\"extra\", {})\n        extra.update({\"content_type\": self.content_type})\n\n        metadata = self.get(\"metadata\", None)\n        if metadata is not None:\n            warnings.warn(\n                'metadata attribute is deprecated. Use extra={\"meta_data\": ...} instead',\n                DeprecationWarning,\n                stacklevel=1,\n            )\n            extra.update({\"meta_data\": metadata})\n\n        if extra.get(\"meta_data\", None) is None:\n            extra[\"meta_data\"] = {}\n\n        extra[\"meta_data\"].update(\n            {\"filename\": self.filename, \"content_type\": self.content_type}\n        )\n        stored_file = self.store_content(\n            self.original_content,\n            upload_storage,\n            extra=extra,\n            headers=self.get(\"headers\", None),\n            content_path=self.content_path,\n        )\n        self[\"file_id\"] = stored_file.name\n        self[\"upload_storage\"] = upload_storage\n        self[\"uploaded_at\"] = datetime.utcnow().isoformat()\n        self[\"path\"] = f\"{upload_storage}/{stored_file.name}\"\n        self[\"url\"] = stored_file.get_cdn_url()\n        self[\"saved\"] = True\n\n    def store_content(\n        self,\n        content: Any,\n        upload_storage: Optional[str] = None,\n        name: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        extra: Optional[Dict[str, Any]] = None,\n        headers: Optional[Dict[str, str]] = None,\n        content_path: Optional[str] = None,\n    ) -&gt; StoredFile:\n        \"\"\"Store content into provided `upload_storage`\n        with additional `metadata`. Can be used by processors\n        to store additional files.\n        \"\"\"\n        name = name or str(uuid.uuid4())\n        stored_file = StorageManager.save_file(\n            name=name,\n            content=content,\n            upload_storage=upload_storage,\n            metadata=metadata,\n            extra=extra,\n            headers=headers,\n            content_path=content_path,\n        )\n        self[\"files\"].append(f\"{upload_storage}/{name}\")\n        return stored_file\n\n    def encode(self) -&gt; Dict[str, Any]:\n        return {k: v for k, v in self.items() if k not in [\"original_content\"]}\n\n    @classmethod\n    def decode(cls, data: Any) -&gt; \"File\":\n        return cls(data)\n\n    @property\n    def file(self) -&gt; \"StoredFile\":\n        if self.get(\"saved\", False):\n            return StorageManager.get_file(self[\"path\"])\n        raise RuntimeError(\"Only available for saved file\")\n</code></pre>"},{"location":"api/file/#sqlalchemy_file.file.File.apply_processors","title":"<code>apply_processors(processors, upload_storage=None)</code>","text":"<p>Apply processors to current file.</p> Source code in <code>sqlalchemy_file/file.py</code> <pre><code>def apply_processors(\n    self,\n    processors: List[Processor],\n    upload_storage: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Apply processors to current file.\"\"\"\n    for processor in processors:\n        processor.process(self, upload_storage)\n    self._freeze()\n</code></pre>"},{"location":"api/file/#sqlalchemy_file.file.File.apply_validators","title":"<code>apply_validators(validators, key='')</code>","text":"<p>Apply validators to current file.</p> Source code in <code>sqlalchemy_file/file.py</code> <pre><code>def apply_validators(self, validators: List[Validator], key: str = \"\") -&gt; None:\n    \"\"\"Apply validators to current file.\"\"\"\n    for validator in validators:\n        validator.process(self, key)\n</code></pre>"},{"location":"api/file/#sqlalchemy_file.file.File.save_to_storage","title":"<code>save_to_storage(upload_storage=None)</code>","text":"<p>Save current file into provided <code>upload_storage</code>.</p> Source code in <code>sqlalchemy_file/file.py</code> <pre><code>def save_to_storage(self, upload_storage: Optional[str] = None) -&gt; None:\n    \"\"\"Save current file into provided `upload_storage`.\"\"\"\n    extra = self.get(\"extra\", {})\n    extra.update({\"content_type\": self.content_type})\n\n    metadata = self.get(\"metadata\", None)\n    if metadata is not None:\n        warnings.warn(\n            'metadata attribute is deprecated. Use extra={\"meta_data\": ...} instead',\n            DeprecationWarning,\n            stacklevel=1,\n        )\n        extra.update({\"meta_data\": metadata})\n\n    if extra.get(\"meta_data\", None) is None:\n        extra[\"meta_data\"] = {}\n\n    extra[\"meta_data\"].update(\n        {\"filename\": self.filename, \"content_type\": self.content_type}\n    )\n    stored_file = self.store_content(\n        self.original_content,\n        upload_storage,\n        extra=extra,\n        headers=self.get(\"headers\", None),\n        content_path=self.content_path,\n    )\n    self[\"file_id\"] = stored_file.name\n    self[\"upload_storage\"] = upload_storage\n    self[\"uploaded_at\"] = datetime.utcnow().isoformat()\n    self[\"path\"] = f\"{upload_storage}/{stored_file.name}\"\n    self[\"url\"] = stored_file.get_cdn_url()\n    self[\"saved\"] = True\n</code></pre>"},{"location":"api/file/#sqlalchemy_file.file.File.store_content","title":"<code>store_content(content, upload_storage=None, name=None, metadata=None, extra=None, headers=None, content_path=None)</code>","text":"<p>Store content into provided <code>upload_storage</code> with additional <code>metadata</code>. Can be used by processors to store additional files.</p> Source code in <code>sqlalchemy_file/file.py</code> <pre><code>def store_content(\n    self,\n    content: Any,\n    upload_storage: Optional[str] = None,\n    name: Optional[str] = None,\n    metadata: Optional[Dict[str, Any]] = None,\n    extra: Optional[Dict[str, Any]] = None,\n    headers: Optional[Dict[str, str]] = None,\n    content_path: Optional[str] = None,\n) -&gt; StoredFile:\n    \"\"\"Store content into provided `upload_storage`\n    with additional `metadata`. Can be used by processors\n    to store additional files.\n    \"\"\"\n    name = name or str(uuid.uuid4())\n    stored_file = StorageManager.save_file(\n        name=name,\n        content=content,\n        upload_storage=upload_storage,\n        metadata=metadata,\n        extra=extra,\n        headers=headers,\n        content_path=content_path,\n    )\n    self[\"files\"].append(f\"{upload_storage}/{name}\")\n    return stored_file\n</code></pre>"},{"location":"api/processors/","title":"Processors","text":"<p>Interface that must be implemented by file processors. Can be used to add additional data to the stored file or change it. When file processors are run the file has already been stored.</p> Source code in <code>sqlalchemy_file/processors.py</code> <pre><code>class Processor:\n    \"\"\"Interface that must be implemented by file processors.\n    Can be used to add additional data to the stored file or change it.\n    When file processors are run the file has already been stored.\n\n    \"\"\"\n\n    @abstractmethod\n    def process(\n        self, file: \"File\", upload_storage: Optional[str] = None\n    ) -&gt; None:  # pragma: no cover\n        \"\"\"Should be overridden in inherited class\n        Parameters:\n            file: [File][sqlalchemy_file.file.File] object,\n                Use file.original_content to access uploaded file\n            upload_storage: pass this to\n                [file.store_content()][sqlalchemy_file.file.File.store_content]\n                to attach additional files to the original file.\n        \"\"\"\n</code></pre> <p>             Bases: <code>Processor</code></p> <p>Generate thumbnail from original content.</p> <p>The default thumbnail format and size are <code>PNG@128x128</code>, those can be changed by giving custom <code>thumbnail_size</code> and <code>thumbnail_format</code></p> <p>Note</p> <p>ThumbnailGenerator will add additional data to the file object under the key <code>thumbnail</code>. These data will be store in database.</p> <p>Properties available in <code>thumbnail</code> attribute</p> <ul> <li>file_id:        This is the ID of the uploaded thumbnail file</li> <li>upload_storage: Name of the storage used to save the uploaded file</li> <li>path:           This is a upload_storage/file_id path which can                         be used with :meth:<code>StorageManager.get_file</code> to                         retrieve the thumbnail file</li> <li>width           This is the width of the thumbnail image</li> <li>height:         This is the height of the thumbnail image</li> <li>url:            Public url of the uploaded file provided                         by libcloud method <code>Object.get_cdn_url()</code></li> </ul> Example <pre><code>class Book(Base):\n    __tablename__ = \"book\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    title = Column(String(100), unique=True)\n    cover = Column(ImageField(processors=[ThumbnailGenerator()]))\n</code></pre> <pre><code>def test_create_image_with_thumbnail(self, fake_image) -&gt; None:\n    with Session(engine) as session:\n        from PIL import Image\n\n        session.add(Book(title=\"Pointless Meetings\", cover=fake_image))\n        session.flush()\n        book = session.execute(\n            select(Book).where(Book.title == \"Pointless Meetings\")\n        ).scalar_one()\n        assert book.cover[\"thumbnail\"] is not None\n        thumbnail = StorageManager.get_file(book.cover[\"thumbnail\"][\"path\"])\n        assert thumbnail is not None\n        thumbnail = Image.open(thumbnail)\n        assert max(thumbnail.width, thumbnail.height) == 128\n        assert book.cover[\"thumbnail\"][\"width\"] == thumbnail.width\n        assert book.cover[\"thumbnail\"][\"height\"] == thumbnail.height\n</code></pre> Source code in <code>sqlalchemy_file/processors.py</code> <pre><code>class ThumbnailGenerator(Processor):\n    \"\"\"Generate thumbnail from original content.\n\n    The default thumbnail format and size are `PNG@128x128`, those can be changed\n    by giving custom `thumbnail_size` and `thumbnail_format`\n\n    !!! note\n        ThumbnailGenerator will add additional data\n        to the file object under the key `thumbnail`.\n        These data will be store in database.\n\n        Properties available in `thumbnail` attribute\n\n        - **file_id:**        This is the ID of the uploaded thumbnail file\n        - **upload_storage:** Name of the storage used to save the uploaded file\n        - **path:**           This is a upload_storage/file_id path which can\n                                be used with :meth:`StorageManager.get_file` to\n                                retrieve the thumbnail file\n        - **width**           This is the width of the thumbnail image\n        - **height:**         This is the height of the thumbnail image\n        - **url:**            Public url of the uploaded file provided\n                                by libcloud method `Object.get_cdn_url()`\n\n    Example:\n        ```Python\n        class Book(Base):\n            __tablename__ = \"book\"\n\n            id = Column(Integer, autoincrement=True, primary_key=True)\n            title = Column(String(100), unique=True)\n            cover = Column(ImageField(processors=[ThumbnailGenerator()]))\n        ```\n\n        ```Python\n        def test_create_image_with_thumbnail(self, fake_image) -&gt; None:\n            with Session(engine) as session:\n                from PIL import Image\n\n                session.add(Book(title=\"Pointless Meetings\", cover=fake_image))\n                session.flush()\n                book = session.execute(\n                    select(Book).where(Book.title == \"Pointless Meetings\")\n                ).scalar_one()\n                assert book.cover[\"thumbnail\"] is not None\n                thumbnail = StorageManager.get_file(book.cover[\"thumbnail\"][\"path\"])\n                assert thumbnail is not None\n                thumbnail = Image.open(thumbnail)\n                assert max(thumbnail.width, thumbnail.height) == 128\n                assert book.cover[\"thumbnail\"][\"width\"] == thumbnail.width\n                assert book.cover[\"thumbnail\"][\"height\"] == thumbnail.height\n        ```\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        thumbnail_size: Tuple[int, int] = (128, 128),\n        thumbnail_format: str = \"PNG\",\n    ) -&gt; None:\n        super().__init__()\n        self.thumbnail_size = thumbnail_size\n        self.thumbnail_format = thumbnail_format\n\n    def process(self, file: \"File\", upload_storage: Optional[str] = None) -&gt; None:\n        from PIL import Image  # type: ignore\n\n        content = file.original_content\n        img = Image.open(content)\n        thumbnail = img.copy()\n        thumbnail.thumbnail(self.thumbnail_size)\n        output = SpooledTemporaryFile(INMEMORY_FILESIZE)\n        thumbnail.save(output, self.thumbnail_format)\n        output.seek(0)\n        width, height, content_type = (\n            thumbnail.width,\n            thumbnail.height,\n            f\"image/{self.thumbnail_format}\".lower(),\n        )\n        ext = mimetypes.guess_extension(content_type)\n        extra = file.get(\"extra\", {})\n        metadata = extra.get(\"meta_data\", {})\n        metadata.update(\n            {\n                \"filename\": file[\"filename\"] + f\".thumbnail{width}x{height}{ext}\",\n                \"content_type\": content_type,\n                \"width\": width,\n                \"height\": height,\n            }\n        )\n        extra.update({\"content_type\": content_type, \"meta_data\": metadata})\n        stored_file = file.store_content(\n            output,\n            upload_storage=upload_storage,\n            extra=extra,\n            headers=file.get(\"headers\", None),\n        )\n        file.update(\n            {\n                \"thumbnail\": {\n                    \"file_id\": stored_file.name,\n                    \"width\": width,\n                    \"height\": height,\n                    \"upload_storage\": upload_storage,\n                    \"path\": f\"{upload_storage}/{stored_file.name}\",\n                    \"url\": stored_file.get_cdn_url(),\n                }\n            }\n        )\n</code></pre>"},{"location":"api/processors/#sqlalchemy_file.processors.Processor.process","title":"<code>process(file, upload_storage=None)</code>  <code>abstractmethod</code>","text":"<p>Should be overridden in inherited class Parameters:     file: File object,         Use file.original_content to access uploaded file     upload_storage: pass this to         file.store_content()         to attach additional files to the original file.</p> Source code in <code>sqlalchemy_file/processors.py</code> <pre><code>@abstractmethod\ndef process(\n    self, file: \"File\", upload_storage: Optional[str] = None\n) -&gt; None:  # pragma: no cover\n    \"\"\"Should be overridden in inherited class\n    Parameters:\n        file: [File][sqlalchemy_file.file.File] object,\n            Use file.original_content to access uploaded file\n        upload_storage: pass this to\n            [file.store_content()][sqlalchemy_file.file.File.store_content]\n            to attach additional files to the original file.\n    \"\"\"\n</code></pre>"},{"location":"api/storage-manager/","title":"StorageManager","text":"<p>Takes care of managing the whole Storage environment for the application.</p> <p>Use add_storage method to add new <code>libcloud.storage.base.Container</code>and associate a name which will be use later to retrieve this container.</p> <p>The first container will be used as default, to simplify code when you have only one container.</p> <p>Use associated name as <code>upload_storage</code> for FileField to store his files inside the corresponding container.</p> Source code in <code>sqlalchemy_file/storage.py</code> <pre><code>class StorageManager:\n    \"\"\"Takes care of managing the whole Storage environment for the application.\n\n    Use [add_storage][sqlalchemy_file.storage.StorageManager.add_storage] method\n    to add new `libcloud.storage.base.Container`and associate a name which\n    will be use later to retrieve this container.\n\n    The first container will be used as default, to simplify code when you have\n    only one container.\n\n    Use associated name as `upload_storage` for [FileField][sqlalchemy_file.types.FileField]\n    to store his files inside the corresponding container.\n\n    \"\"\"\n\n    _default_storage_name: ClassVar[Optional[str]] = None\n    _storages: ClassVar[Dict[str, Container]] = {}\n\n    @classmethod\n    def set_default(cls, name: str) -&gt; None:\n        \"\"\"Replaces the current application default storage.\"\"\"\n        if name not in cls._storages:\n            raise RuntimeError(f\"{name} storage has not been added\")\n        cls._default_storage_name = name\n\n    @classmethod\n    def get_default(cls) -&gt; str:\n        \"\"\"Gets the current application default storage.\"\"\"\n        if cls._default_storage_name is None:\n            raise RuntimeError(\"No default storage has been added\")\n        return cls._default_storage_name\n\n    @classmethod\n    def add_storage(cls, name: str, container: Container) -&gt; None:\n        \"\"\"Add new storage.\"\"\"\n        assert isinstance(container, Container), \"Invalid container\"\n        if name in cls._storages:\n            raise RuntimeError(f\"Storage {name} has already been added\")\n        if cls._default_storage_name is None:\n            cls._default_storage_name = name\n        cls._storages[name] = container\n\n    @classmethod\n    def get(cls, name: Optional[str] = None) -&gt; Container:\n        \"\"\"Gets the container instance associate to the name,\n        return default if name isn't provided.\n        \"\"\"\n        if name is None and cls._default_storage_name is None:\n            raise RuntimeError(\"No default storage have been added\")\n        if name is None:\n            name = cls._default_storage_name\n        if name in cls._storages:\n            return cls._storages[name]\n        raise RuntimeError(f\"{name} storage has not been added\")\n\n    @classmethod\n    def save_file(\n        cls,\n        name: str,\n        content: Optional[Iterator[bytes]] = None,\n        upload_storage: Optional[str] = None,\n        metadata: Optional[Dict[str, Any]] = None,\n        extra: Optional[Dict[str, Any]] = None,\n        headers: Optional[Dict[str, str]] = None,\n        content_path: Optional[str] = None,\n    ) -&gt; StoredFile:\n        if content is None and content_path is None:\n            raise ValueError(\"Either content or content_path must be specified\")\n        if metadata is not None:\n            warnings.warn(\n                'metadata attribute is deprecated. Use extra={\"meta_data\": ...} instead',\n                DeprecationWarning,\n                stacklevel=1,\n            )\n            extra = {\n                \"meta_data\": metadata,\n                \"content_type\": metadata.get(\n                    \"content_type\", \"application/octet-stream\"\n                ),\n            }\n        \"\"\"Save file into provided `upload_storage`\"\"\"\n        container = cls.get(upload_storage)\n        if (\n            container.driver.name == LOCAL_STORAGE_DRIVER_NAME\n            and extra is not None\n            and extra.get(\"meta_data\", None) is not None\n        ):\n            \"\"\"\n            Libcloud local storage driver doesn't support metadata, so the metadata\n            is saved in the same container with the combination of the original name\n            and `.metadata.json` as name\n            \"\"\"\n            container.upload_object_via_stream(\n                iterator=get_metadata_file_obj(extra[\"meta_data\"]),\n                object_name=f\"{name}.metadata.json\",\n            )\n        if content_path is not None:\n            return StoredFile(\n                container.upload_object(\n                    file_path=content_path,\n                    object_name=name,\n                    extra=extra,\n                    headers=headers,\n                )\n            )\n        assert content is not None\n        return StoredFile(\n            container.upload_object_via_stream(\n                iterator=content, object_name=name, extra=extra, headers=headers\n            )\n        )\n\n    @classmethod\n    def get_file(cls, path: str) -&gt; StoredFile:\n        \"\"\"Retrieve the file with `provided` path.\n\n        The path is expected to be `storage_name/file_id`.\n        \"\"\"\n        upload_storage, file_id = cls._get_storage_and_file_id(path)\n        return StoredFile(StorageManager.get(upload_storage).get_object(file_id))\n\n    @classmethod\n    def delete_file(cls, path: str) -&gt; bool:\n        \"\"\"Delete the file with `provided` path.\n\n        The path is expected to be `storage_name/file_id`.\n        \"\"\"\n        upload_storage, file_id = cls._get_storage_and_file_id(path)\n        obj = StorageManager.get(upload_storage).get_object(file_id)\n        if obj.driver.name == LOCAL_STORAGE_DRIVER_NAME:\n            \"\"\"Try deleting associated metadata file\"\"\"\n            with contextlib.suppress(ObjectDoesNotExistError):\n                obj.container.get_object(f\"{obj.name}.metadata.json\").delete()\n\n        return obj.delete()\n\n    @classmethod\n    def _clear(cls) -&gt; None:\n        \"\"\"This is only for testing purposes, resets the StorageManager.\"\"\"\n        cls._default_storage_name = None\n        cls._storages = {}\n\n    @classmethod\n    def _get_storage_and_file_id(cls, path: str) -&gt; Tuple[str, str]:\n        \"\"\"Extract the storage name and file_id from the path.\n\n        The path is expected to be `storage_name/file_id`.\n        \"\"\"\n        path_parts = path.split(\"/\")\n        return \"/\".join(path_parts[:-1]), path_parts[-1]\n</code></pre>"},{"location":"api/storage-manager/#sqlalchemy_file.storage.StorageManager.add_storage","title":"<code>add_storage(name, container)</code>  <code>classmethod</code>","text":"<p>Add new storage.</p> Source code in <code>sqlalchemy_file/storage.py</code> <pre><code>@classmethod\ndef add_storage(cls, name: str, container: Container) -&gt; None:\n    \"\"\"Add new storage.\"\"\"\n    assert isinstance(container, Container), \"Invalid container\"\n    if name in cls._storages:\n        raise RuntimeError(f\"Storage {name} has already been added\")\n    if cls._default_storage_name is None:\n        cls._default_storage_name = name\n    cls._storages[name] = container\n</code></pre>"},{"location":"api/storage-manager/#sqlalchemy_file.storage.StorageManager.delete_file","title":"<code>delete_file(path)</code>  <code>classmethod</code>","text":"<p>Delete the file with <code>provided</code> path.</p> <p>The path is expected to be <code>storage_name/file_id</code>.</p> Source code in <code>sqlalchemy_file/storage.py</code> <pre><code>@classmethod\ndef delete_file(cls, path: str) -&gt; bool:\n    \"\"\"Delete the file with `provided` path.\n\n    The path is expected to be `storage_name/file_id`.\n    \"\"\"\n    upload_storage, file_id = cls._get_storage_and_file_id(path)\n    obj = StorageManager.get(upload_storage).get_object(file_id)\n    if obj.driver.name == LOCAL_STORAGE_DRIVER_NAME:\n        \"\"\"Try deleting associated metadata file\"\"\"\n        with contextlib.suppress(ObjectDoesNotExistError):\n            obj.container.get_object(f\"{obj.name}.metadata.json\").delete()\n\n    return obj.delete()\n</code></pre>"},{"location":"api/storage-manager/#sqlalchemy_file.storage.StorageManager.get","title":"<code>get(name=None)</code>  <code>classmethod</code>","text":"<p>Gets the container instance associate to the name, return default if name isn't provided.</p> Source code in <code>sqlalchemy_file/storage.py</code> <pre><code>@classmethod\ndef get(cls, name: Optional[str] = None) -&gt; Container:\n    \"\"\"Gets the container instance associate to the name,\n    return default if name isn't provided.\n    \"\"\"\n    if name is None and cls._default_storage_name is None:\n        raise RuntimeError(\"No default storage have been added\")\n    if name is None:\n        name = cls._default_storage_name\n    if name in cls._storages:\n        return cls._storages[name]\n    raise RuntimeError(f\"{name} storage has not been added\")\n</code></pre>"},{"location":"api/storage-manager/#sqlalchemy_file.storage.StorageManager.get_default","title":"<code>get_default()</code>  <code>classmethod</code>","text":"<p>Gets the current application default storage.</p> Source code in <code>sqlalchemy_file/storage.py</code> <pre><code>@classmethod\ndef get_default(cls) -&gt; str:\n    \"\"\"Gets the current application default storage.\"\"\"\n    if cls._default_storage_name is None:\n        raise RuntimeError(\"No default storage has been added\")\n    return cls._default_storage_name\n</code></pre>"},{"location":"api/storage-manager/#sqlalchemy_file.storage.StorageManager.get_file","title":"<code>get_file(path)</code>  <code>classmethod</code>","text":"<p>Retrieve the file with <code>provided</code> path.</p> <p>The path is expected to be <code>storage_name/file_id</code>.</p> Source code in <code>sqlalchemy_file/storage.py</code> <pre><code>@classmethod\ndef get_file(cls, path: str) -&gt; StoredFile:\n    \"\"\"Retrieve the file with `provided` path.\n\n    The path is expected to be `storage_name/file_id`.\n    \"\"\"\n    upload_storage, file_id = cls._get_storage_and_file_id(path)\n    return StoredFile(StorageManager.get(upload_storage).get_object(file_id))\n</code></pre>"},{"location":"api/storage-manager/#sqlalchemy_file.storage.StorageManager.set_default","title":"<code>set_default(name)</code>  <code>classmethod</code>","text":"<p>Replaces the current application default storage.</p> Source code in <code>sqlalchemy_file/storage.py</code> <pre><code>@classmethod\ndef set_default(cls, name: str) -&gt; None:\n    \"\"\"Replaces the current application default storage.\"\"\"\n    if name not in cls._storages:\n        raise RuntimeError(f\"{name} storage has not been added\")\n    cls._default_storage_name = name\n</code></pre>"},{"location":"api/types/","title":"Types","text":"<p>             Bases: <code>TypeDecorator</code></p> <p>Provides support for storing attachments to SQLAlchemy models.</p> <p>FileField can be used as a Column type to store files into the model. The actual file itself will be uploaded to a specific <code>libcloud.storage.base.Container</code>, and only the File information will be stored on the database as JSON.</p> <p>FileField is transaction aware, so it will delete every uploaded file whenever the transaction is rolled back and will delete any old file whenever the transaction is committed.</p> <p>You can save <code>str</code>, <code>bytes</code> or any python <code>file</code> object</p> <p>Each file will be validated by provided validators before being saved into associate storage <code>libcloud.storage.base.Container</code> and can go through different processors before being saved in the database.</p> Source code in <code>sqlalchemy_file/types.py</code> <pre><code>class FileField(types.TypeDecorator):  # type: ignore\n    \"\"\"Provides support for storing attachments to **SQLAlchemy** models.\n\n    [FileField][sqlalchemy_file.types.FileField] can be used as a Column type to\n    store files into the model. The actual file itself will be uploaded to a specific\n    `libcloud.storage.base.Container`, and only the [File][sqlalchemy_file.file.File]\n    information will be stored on the database as JSON.\n\n    [FileField][sqlalchemy_file.types.FileField] is transaction aware, so it will delete\n    every uploaded file whenever the transaction is rolled back and will\n    delete any old file whenever the transaction is committed.\n\n    You can save `str`, `bytes` or any python `file` object\n\n    Each file will be validated by provided validators before being saved into\n    associate storage `libcloud.storage.base.Container` and can go through different\n    processors before being saved in the database.\n\n    \"\"\"\n\n    impl = types.JSON\n    cache_ok = False\n\n    @property\n    def python_type(self) -&gt; Type[Union[File, List[File]]]:\n        if self.multiple:\n            return MutableList[File]\n        return File\n\n    def __init__(\n        self,\n        *args: Tuple[Any],\n        upload_storage: Optional[str] = None,\n        validators: Optional[List[Validator]] = None,\n        processors: Optional[List[Processor]] = None,\n        upload_type: Type[File] = File,\n        multiple: Optional[bool] = False,\n        extra: Optional[Dict[str, Any]] = None,\n        headers: Optional[Dict[str, str]] = None,\n        **kwargs: Dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Parameters:\n        upload_storage: storage to use\n        validators: List of validators to apply\n        processors: List of processors to apply\n        upload_type: File class to use, could be\n        used to set custom File class\n        multiple: Use this to save multiple files\n        extra: Extra attributes (driver specific)\n        headers: Additional request headers,\n        such as CORS headers. For example:\n        headers = {'Access-Control-Allow-Origin': 'http://mozilla.com'}.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        if processors is None:\n            processors = []\n        if validators is None:\n            validators = []\n        self.upload_storage = upload_storage\n        self.upload_type = upload_type\n        self.multiple = multiple\n        self.extra = extra\n        self.headers = headers\n        self.validators = validators\n        self.processors = processors\n\n    def process_bind_param(\n        self, value: Any, dialect: Dialect\n    ) -&gt; Union[None, Dict[str, Any], List[Dict[str, Any]]]:\n        if not value:\n            return None\n        if not self.multiple and not isinstance(\n            value, self.upload_type\n        ):  # pragma: no cover\n            raise ValueError(f\"Expected {self.upload_type}, received: {type(value)}\")\n        if self.multiple and not (\n            isinstance(value, list)\n            and all(isinstance(v, self.upload_type) for v in value)\n        ):  # pragma: no cover\n            raise ValueError(\n                f\"Expected MutableList[{self.upload_type}], received: {type(value)}\"\n            )\n        return [v.encode() for v in value] if self.multiple else value.encode()\n\n    def process_result_value(\n        self, value: Any, dialect: Dialect\n    ) -&gt; Union[None, MutableList[File], File]:\n        if value is None:\n            return None\n        if isinstance(value, dict):\n            return (\n                MutableList([self.upload_type.decode(value)])\n                if self.multiple\n                else self.upload_type.decode(value)\n            )\n        return MutableList([self.upload_type.decode(v) for v in value])\n</code></pre> <p>             Bases: <code>FileField</code></p> <p>Inherits all attributes and methods from FileField, but also validates that the uploaded object is a valid image.</p> Source code in <code>sqlalchemy_file/types.py</code> <pre><code>class ImageField(FileField):\n    \"\"\"Inherits all attributes and methods from [FileField][sqlalchemy_file.types.FileField],\n    but also validates that the uploaded object is a valid image.\n    \"\"\"\n\n    cache_ok = False\n\n    def __init__(\n        self,\n        *args: Tuple[Any],\n        upload_storage: Optional[str] = None,\n        thumbnail_size: Optional[Tuple[int, int]] = None,\n        image_validator: Optional[ImageValidator] = None,\n        validators: Optional[List[Validator]] = None,\n        processors: Optional[List[Processor]] = None,\n        upload_type: Type[File] = File,\n        multiple: Optional[bool] = False,\n        extra: Optional[Dict[str, str]] = None,\n        headers: Optional[Dict[str, str]] = None,\n        **kwargs: Dict[str, Any],\n    ) -&gt; None:\n        \"\"\"Parameters\n        upload_storage: storage to use\n        image_validator: ImageField use default image\n        validator, Use this property to customize it.\n        thumbnail_size: If set, a thumbnail will be generated\n        from original image using [ThumbnailGenerator]\n        [sqlalchemy_file.processors.ThumbnailGenerator]\n        validators: List of additional validators to apply\n        processors: List of validators to apply\n        upload_type: File class to use, could be\n        used to set custom File class\n        multiple: Use this to save multiple files\n        extra: Extra attributes (driver specific).\n        \"\"\"\n        if validators is None:\n            validators = []\n        if image_validator is None:\n            image_validator = ImageValidator()\n        if thumbnail_size is not None:\n            if processors is None:\n                processors = []\n            processors.append(ThumbnailGenerator(thumbnail_size))\n        validators.append(image_validator)\n        super().__init__(\n            *args,\n            upload_storage=upload_storage,\n            validators=validators,\n            processors=processors,\n            upload_type=upload_type,\n            multiple=multiple,\n            extra=extra,\n            headers=headers,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/types/#sqlalchemy_file.types.FileField.__init__","title":"<code>__init__(*args, upload_storage=None, validators=None, processors=None, upload_type=File, multiple=False, extra=None, headers=None, **kwargs)</code>","text":"<p>Parameters: upload_storage: storage to use validators: List of validators to apply processors: List of processors to apply upload_type: File class to use, could be used to set custom File class multiple: Use this to save multiple files extra: Extra attributes (driver specific) headers: Additional request headers, such as CORS headers. For example: headers = {'Access-Control-Allow-Origin': 'http://mozilla.com'}.</p> Source code in <code>sqlalchemy_file/types.py</code> <pre><code>def __init__(\n    self,\n    *args: Tuple[Any],\n    upload_storage: Optional[str] = None,\n    validators: Optional[List[Validator]] = None,\n    processors: Optional[List[Processor]] = None,\n    upload_type: Type[File] = File,\n    multiple: Optional[bool] = False,\n    extra: Optional[Dict[str, Any]] = None,\n    headers: Optional[Dict[str, str]] = None,\n    **kwargs: Dict[str, Any],\n) -&gt; None:\n    \"\"\"Parameters:\n    upload_storage: storage to use\n    validators: List of validators to apply\n    processors: List of processors to apply\n    upload_type: File class to use, could be\n    used to set custom File class\n    multiple: Use this to save multiple files\n    extra: Extra attributes (driver specific)\n    headers: Additional request headers,\n    such as CORS headers. For example:\n    headers = {'Access-Control-Allow-Origin': 'http://mozilla.com'}.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    if processors is None:\n        processors = []\n    if validators is None:\n        validators = []\n    self.upload_storage = upload_storage\n    self.upload_type = upload_type\n    self.multiple = multiple\n    self.extra = extra\n    self.headers = headers\n    self.validators = validators\n    self.processors = processors\n</code></pre>"},{"location":"api/types/#sqlalchemy_file.types.ImageField.__init__","title":"<code>__init__(*args, upload_storage=None, thumbnail_size=None, image_validator=None, validators=None, processors=None, upload_type=File, multiple=False, extra=None, headers=None, **kwargs)</code>","text":"<p>Parameters upload_storage: storage to use image_validator: ImageField use default image validator, Use this property to customize it. thumbnail_size: If set, a thumbnail will be generated from original image using ThumbnailGenerator validators: List of additional validators to apply processors: List of validators to apply upload_type: File class to use, could be used to set custom File class multiple: Use this to save multiple files extra: Extra attributes (driver specific).</p> Source code in <code>sqlalchemy_file/types.py</code> <pre><code>def __init__(\n    self,\n    *args: Tuple[Any],\n    upload_storage: Optional[str] = None,\n    thumbnail_size: Optional[Tuple[int, int]] = None,\n    image_validator: Optional[ImageValidator] = None,\n    validators: Optional[List[Validator]] = None,\n    processors: Optional[List[Processor]] = None,\n    upload_type: Type[File] = File,\n    multiple: Optional[bool] = False,\n    extra: Optional[Dict[str, str]] = None,\n    headers: Optional[Dict[str, str]] = None,\n    **kwargs: Dict[str, Any],\n) -&gt; None:\n    \"\"\"Parameters\n    upload_storage: storage to use\n    image_validator: ImageField use default image\n    validator, Use this property to customize it.\n    thumbnail_size: If set, a thumbnail will be generated\n    from original image using [ThumbnailGenerator]\n    [sqlalchemy_file.processors.ThumbnailGenerator]\n    validators: List of additional validators to apply\n    processors: List of validators to apply\n    upload_type: File class to use, could be\n    used to set custom File class\n    multiple: Use this to save multiple files\n    extra: Extra attributes (driver specific).\n    \"\"\"\n    if validators is None:\n        validators = []\n    if image_validator is None:\n        image_validator = ImageValidator()\n    if thumbnail_size is not None:\n        if processors is None:\n            processors = []\n        processors.append(ThumbnailGenerator(thumbnail_size))\n    validators.append(image_validator)\n    super().__init__(\n        *args,\n        upload_storage=upload_storage,\n        validators=validators,\n        processors=processors,\n        upload_type=upload_type,\n        multiple=multiple,\n        extra=extra,\n        headers=headers,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/validators/","title":"Validators","text":"<p>Interface that must be implemented by file validators.</p> <p>File validators get executed before a file is stored on the database using one of the supported fields. Can be used to add additional data to file object or change it.</p> Source code in <code>sqlalchemy_file/validators.py</code> <pre><code>class Validator:\n    \"\"\"Interface that must be implemented by file validators.\n\n    File validators get executed before a file is stored on the database\n    using one of the supported fields. Can be used to add additional data\n    to file object or change it.\n\n    \"\"\"\n\n    @abstractmethod\n    def process(self, file: \"File\", attr_key: str) -&gt; None:  # pragma: no cover\n        \"\"\"Should be overridden in inherited class.\n\n        Parameters:\n           file: [File][sqlalchemy_file.file.File] object\n           attr_key: current SQLAlchemy column key. Can be passed to\n               [ValidationError][sqlalchemy_file.exceptions.ValidationError]\n        \"\"\"\n</code></pre> <p>             Bases: <code>Validator</code></p> <p>Validate file maximum size.</p> <p>Attributes:</p> Name Type Description <code>max_size</code> <p>If set, the size of the underlying file must be below this file size in order to be valid. The size of the file can be given in one of the following formats:</p> Suffix Unit Name Value Example (none) byte 1 byte <code>4096</code> k kilobyte 1,000 bytes <code>200k</code> M megabyte 1,000,000 bytes <code>2M</code> Ki kibibyte 1,024 bytes <code>32Ki</code> Mi mebibyte 1,048,576 bytes <code>8Mi</code> <p>For more information, view Wikipedia: Binary prefix</p> Example <pre><code>class Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(FileField(validators=[SizeValidator(max_size=\"2M\")]))\n</code></pre> <p>Raises:</p> Type Description <code>SizeValidationError</code> <p>When file <code>size</code> is greater than max_size</p> Source code in <code>sqlalchemy_file/validators.py</code> <pre><code>class SizeValidator(Validator):\n    \"\"\"Validate file maximum size.\n\n    Attributes:\n        max_size:\n            If set, the size of the underlying file must\n            be below this file size in order to be valid.\n            The size of the file can be given in one of\n            the following formats:\n\n            | **Suffix** | **Unit Name** | **Value**       | **Example** |\n            |------------|---------------|-----------------|-------------|\n            | (none)     | byte          | 1 byte          | `4096`      |\n            | k          | kilobyte      | 1,000 bytes     | `200k`      |\n            | M          | megabyte      | 1,000,000 bytes | `2M`        |\n            | Ki         | kibibyte      | 1,024 bytes     | `32Ki`      |\n            | Mi         | mebibyte      | 1,048,576 bytes | `8Mi`       |\n\n            For more information, view\n            [Wikipedia: Binary prefix](https://en.wikipedia.org/wiki/Binary_prefix)\n\n    Example:\n        ```Python\n        class Attachment(Base):\n            __tablename__ = \"attachment\"\n\n            id = Column(Integer, autoincrement=True, primary_key=True)\n            name = Column(String(50), unique=True)\n            content = Column(FileField(validators=[SizeValidator(max_size=\"2M\")]))\n        ```\n\n    Raises:\n        SizeValidationError: When file `size` is greater than max_size\n\n    \"\"\"\n\n    def __init__(self, max_size: Union[int, str] = 0) -&gt; None:\n        super().__init__()\n        self.max_size = max_size\n\n    def process(self, file: \"File\", attr_key: str) -&gt; None:\n        if file.size &gt; convert_size(self.max_size):\n            raise SizeValidationError(\n                attr_key,\n                f\"The file is too large ({file.size} bytes). Allowed maximum size is {self.max_size}.\",\n            )\n</code></pre> <p>             Bases: <code>Validator</code></p> <p>Validate file mimetype Attributes:     allowed_content_types: If set, file <code>content_type</code>                     must be one of the provided list.</p> Example <pre><code>class Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(\n        FileField(validators=[ContentTypeValidator([\"text/plain\", \"text/csv\"])])\n    )\n</code></pre> <p>Raises:</p> Type Description <code>ContentTypeValidationError</code> <p>When file <code>content_type</code> not in allowed_content_types</p> Source code in <code>sqlalchemy_file/validators.py</code> <pre><code>class ContentTypeValidator(Validator):\n    \"\"\"Validate file mimetype\n    Attributes:\n        allowed_content_types: If set, file `content_type`\n                        must be one of the provided list.\n\n    Example:\n        ```Python\n        class Attachment(Base):\n            __tablename__ = \"attachment\"\n\n            id = Column(Integer, autoincrement=True, primary_key=True)\n            name = Column(String(50), unique=True)\n            content = Column(\n                FileField(validators=[ContentTypeValidator([\"text/plain\", \"text/csv\"])])\n            )\n        ```\n\n    Raises:\n        ContentTypeValidationError: When file `content_type` not in allowed_content_types\n\n\n    \"\"\"\n\n    def __init__(self, allowed_content_types: Optional[List[str]] = None) -&gt; None:\n        super().__init__()\n        self.allowed_content_types = allowed_content_types\n\n    def process(self, file: \"File\", attr_key: str) -&gt; None:\n        if (\n            self.allowed_content_types is not None\n            and file.content_type not in self.allowed_content_types\n        ):\n            raise ContentTypeValidationError(\n                attr_key,\n                f\"File content_type {file.content_type} is not allowed. Allowed content_types are: {self.allowed_content_types}\",\n            )\n</code></pre> <p>             Bases: <code>ContentTypeValidator</code></p> <p>Default Validator for ImageField.</p> <p>Attributes:</p> Name Type Description <code>min_wh</code> <p>Minimum allowed dimension (w, h).</p> <code>max_wh</code> <p>Maximum allowed dimension (w, h).</p> <code>allowed_content_types</code> <p>An iterable whose items are         allowed content types. Default is <code>image/*</code></p> <code>min_aspect_ratio</code> <p>Minimum allowed image aspect ratio.</p> <code>max_aspect_ratio</code> <p>Maximum allowed image aspect ratio.</p> Example <pre><code>class Book(Base):\n    __tablename__ = \"book\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    title = Column(String(100), unique=True)\n    cover = Column(\n        ImageField(\n            image_validator=ImageValidator(\n                allowed_content_types=[\"image/x-icon\", \"image/tiff\", \"image/jpeg\"],\n                min_wh=(200, 200),\n                max_wh=(400, 400),\n                min_aspect_ratio=1,\n                max_aspect_ratio=16/9,\n            )\n        )\n    )\n</code></pre> <p>Raises:</p> Type Description <code>ContentTypeValidationError</code> <p>When file <code>content_type</code> not in allowed_content_types</p> <code>InvalidImageError</code> <p>When file is not a valid image</p> <code>DimensionValidationError</code> <p>When image width and height constraints fail.</p> <p>Will add <code>width</code> and <code>height</code> properties to the file object</p> Source code in <code>sqlalchemy_file/validators.py</code> <pre><code>class ImageValidator(ContentTypeValidator):\n    \"\"\"Default Validator for ImageField.\n\n    Attributes:\n        min_wh: Minimum allowed dimension (w, h).\n        max_wh: Maximum allowed dimension (w, h).\n        allowed_content_types: An iterable whose items are\n                    allowed content types. Default is `image/*`\n        min_aspect_ratio: Minimum allowed image aspect ratio.\n        max_aspect_ratio: Maximum allowed image aspect ratio.\n\n    Example:\n        ```Python\n\n        class Book(Base):\n            __tablename__ = \"book\"\n\n            id = Column(Integer, autoincrement=True, primary_key=True)\n            title = Column(String(100), unique=True)\n            cover = Column(\n                ImageField(\n                    image_validator=ImageValidator(\n                        allowed_content_types=[\"image/x-icon\", \"image/tiff\", \"image/jpeg\"],\n                        min_wh=(200, 200),\n                        max_wh=(400, 400),\n                        min_aspect_ratio=1,\n                        max_aspect_ratio=16/9,\n                    )\n                )\n            )\n        ```\n\n    Raises:\n        ContentTypeValidationError: When file `content_type` not in allowed_content_types\n        InvalidImageError: When file is not a valid image\n        DimensionValidationError: When image width and height constraints fail.\n\n    Will add `width` and `height` properties to the file object\n    \"\"\"\n\n    def __init__(\n        self,\n        min_wh: Optional[Tuple[int, int]] = None,\n        max_wh: Optional[Tuple[int, int]] = None,\n        min_aspect_ratio: Optional[float] = None,\n        max_aspect_ratio: Optional[float] = None,\n        allowed_content_types: Optional[List[str]] = None,\n    ):\n        try:\n            from PIL import Image  # type: ignore\n        except ImportError as e:\n            raise ImportError(\n                \"The 'PIL' module is required for image processing, \"\n                \"you can install it using 'pip install Pillow'.\"\n            ) from e\n\n        Image.init()\n        super().__init__(\n            allowed_content_types\n            if allowed_content_types is not None\n            else list(Image.MIME.values())\n        )\n        self.min_width, self.min_height = min_wh if min_wh else (None, None)\n        self.max_width, self.max_height = max_wh if max_wh else (None, None)\n        self.min_aspect_ratio = min_aspect_ratio\n        self.max_aspect_ratio = max_aspect_ratio\n        self.image = Image\n\n    def process(self, file: \"File\", attr_key: str) -&gt; None:\n        super().process(file, attr_key)\n        import PIL\n\n        try:\n            image = self.image.open(file.original_content)\n        except (PIL.UnidentifiedImageError, OSError):\n            raise InvalidImageError(attr_key, \"Provide valid image file\")\n        width, height = image.width, image.height\n        if self.min_width and width &lt; self.min_width:\n            raise DimensionValidationError(\n                attr_key,\n                f\"Minimum allowed width is: {self.min_width}, but {width} is given.\",\n            )\n        if self.min_height and height &lt; self.min_height:\n            raise DimensionValidationError(\n                attr_key,\n                f\"Minimum allowed height is: {self.min_height}, but {height} is given.\",\n            )\n\n        if self.max_width and self.max_width &lt; width:\n            raise DimensionValidationError(\n                attr_key,\n                f\"Maximum allowed width is: {self.max_width}, but {width} is given.\",\n            )\n\n        if self.max_height and self.max_height &lt; height:\n            raise DimensionValidationError(\n                attr_key,\n                f\"Maximum allowed height is: {self.max_height}, but {height} is given.\",\n            )\n        aspect_ratio = width / height\n        if (self.min_aspect_ratio and self.min_aspect_ratio &gt; aspect_ratio) or (\n            self.max_aspect_ratio and self.max_aspect_ratio &lt; aspect_ratio\n        ):\n            raise AspectRatioValidationError(\n                attr_key,\n                f\"Invalid aspect ratio {width} / {height} = {aspect_ratio},\"\n                \"accepted_range: \"\n                f\"{self.min_aspect_ratio} - {self.max_aspect_ratio}\",\n            )\n        file.update({\"width\": width, \"height\": height})\n        file.original_content.seek(0)  # type: ignore[union-attr]\n</code></pre>"},{"location":"api/validators/#sqlalchemy_file.validators.Validator.process","title":"<code>process(file, attr_key)</code>  <code>abstractmethod</code>","text":"<p>Should be overridden in inherited class.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>File</code> <p>File object</p> required <code>attr_key</code> <code>str</code> <p>current SQLAlchemy column key. Can be passed to  ValidationError</p> required Source code in <code>sqlalchemy_file/validators.py</code> <pre><code>@abstractmethod\ndef process(self, file: \"File\", attr_key: str) -&gt; None:  # pragma: no cover\n    \"\"\"Should be overridden in inherited class.\n\n    Parameters:\n       file: [File][sqlalchemy_file.file.File] object\n       attr_key: current SQLAlchemy column key. Can be passed to\n           [ValidationError][sqlalchemy_file.exceptions.ValidationError]\n    \"\"\"\n</code></pre>"},{"location":"tutorial/quick-start/","title":"Quick Start","text":""},{"location":"tutorial/quick-start/#installation","title":"Installation","text":"<p>You can simply install SQLAlchemy-file from the PyPi:</p>"},{"location":"tutorial/quick-start/#pip","title":"PIP","text":"<pre><code>$ pip install sqlalchemy-file\n</code></pre>"},{"location":"tutorial/quick-start/#poetry","title":"Poetry","text":"<pre><code>$ poetry add sqlalchemy-file\n</code></pre>"},{"location":"tutorial/quick-start/#usage","title":"Usage","text":"<p>Getting SQLAlchemy-file setup in your code is really easy:</p> <ul> <li>Add FileField Column to your SQLAlchemy Model</li> </ul> <p>Info</p> <p>When <code>upload_storage</code> is not specified, FileField will use the default storage which is the first added storage</p> <pre><code>from sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\n\nfrom sqlalchemy_file import FileField\n\nBase = declarative_base()\n\n\nclass Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(FileField)\n\n\nengine = create_engine(\n    \"sqlite:///example.db\", connect_args={\"check_same_thread\": False}\n)\nBase.metadata.create_all(engine)\n</code></pre> <ul> <li>Configure Storage</li> </ul> <p>SQLAlchemy-file store files through Apache Libcloud Object Storage API .The <code>StorageManager</code> is the entity in charge of configuring and handling file storages inside your application. To start uploading files, add at least one storage.</p> <p>This can be done by using StorageManager.add_storage() which accepts a storage name (used to identify the storage in case of multiple storages) and the Apache Libcloud container which will be use for this storage.</p> <p>Note</p> <p>The first added storage will be used as default storage</p> <pre><code>import os\n\nfrom libcloud.storage.drivers.local import LocalStorageDriver\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nfrom sqlalchemy_file import FileField\nfrom sqlalchemy_file.storage import StorageManager\n\nBase = declarative_base()\n\n\n# Define your model\nclass Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(FileField)\n\n\n# Configure Storage\nos.makedirs(\"./upload_dir/attachment\", 0o777, exist_ok=True)\ncontainer = LocalStorageDriver(\"./upload_dir\").get_container(\"attachment\")\nStorageManager.add_storage(\"default\", container)\n</code></pre> <ul> <li>Save your model</li> </ul> <p>You can attach <code>str</code>, <code>bytes</code> or any python <code>file</code> object to the column</p> <p>SQLAlchemy-file will try to guess filename and content-type from attached file but you can use <code>sqlalchemy_file.File</code> object to provide custom filename and content-type</p> <pre><code>import os\n\nfrom libcloud.storage.drivers.local import LocalStorageDriver\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session\n\nfrom sqlalchemy_file import FileField, File\nfrom sqlalchemy_file.storage import StorageManager\n\nBase = declarative_base()\n\n\n# Define your model\nclass Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(FileField)\n\n\n# Configure Storage\nos.makedirs(\"./upload_dir/attachment\", 0o777, exist_ok=True)\ncontainer = LocalStorageDriver(\"./upload_dir\").get_container(\"attachment\")\nStorageManager.add_storage(\"default\", container)\n\n\n# Save your model\nengine = create_engine(\n    \"sqlite:///example.db\", connect_args={\"check_same_thread\": False}\n)\nBase.metadata.create_all(engine)\n\nwith Session(engine) as session:\n    session.add(Attachment(name=\"attachment1\", content=open(\"./example.txt\", \"rb\")))\n    session.add(Attachment(name=\"attachment2\", content=b\"Hello world\"))\n    session.add(Attachment(name=\"attachment3\", content=\"Hello world\"))\n    # Use sqlalchemy_file.File object to provide custom filename and content_type\n    file = File(content=\"Hello World\", filename=\"hello.txt\", content_type=\"text/plain\")\n    session.add(Attachment(name=\"attachment4\", content=file))\n    session.commit()\n</code></pre>"},{"location":"tutorial/serving-files/","title":"Serving Files","text":""},{"location":"tutorial/serving-files/#with-fastapi","title":"With FastApi","text":"<pre><code>@app.get(\"/medias/{storage}/{file_id}\", response_class=FileResponse)\ndef serve_files(storage: str = Path(...), file_id: str = Path(...)):\n    try:\n        file = StorageManager.get_file(f\"{storage}/{file_id}\")\n        if isinstance(file.object.driver, LocalStorageDriver):\n            \"\"\"If file is stored in local storage, just return a\n            FileResponse with the fill full path.\"\"\"\n            return FileResponse(\n                file.get_cdn_url(), media_type=file.content_type, filename=file.filename\n            )\n        elif file.get_cdn_url() is not None:\n            \"\"\"If file has public url, redirect to this url\"\"\"\n            return RedirectResponse(file.get_cdn_url())\n        else:\n            \"\"\"Otherwise, return a streaming response\"\"\"\n            return StreamingResponse(\n                file.object.as_stream(),\n                media_type=file.content_type,\n                headers={\"Content-Disposition\": f\"attachment;filename={file.filename}\"},\n            )\n    except ObjectDoesNotExistError:\n        return JSONResponse({\"detail\": \"Not found\"}, status_code=404)\n</code></pre> <p>See full example here</p>"},{"location":"tutorial/serving-files/#with-flask","title":"With Flask","text":"<pre><code>@app.route(\"/medias/&lt;storage&gt;/&lt;file_id&gt;\")\ndef serve_files(storage, file_id):\n    try:\n        file = StorageManager.get_file(f\"{storage}/{file_id}\")\n        if isinstance(file.object.driver, LocalStorageDriver):\n            \"\"\"If file is stored in local storage, just return a\n            FileResponse with the fill full path.\"\"\"\n            return send_file(\n                file.get_cdn_url(),\n                mimetype=file.content_type,\n                download_name=file.filename,\n            )\n        elif file.get_cdn_url() is not None:\n            \"\"\"If file has public url, redirect to this url\"\"\"\n            return app.redirect(file.get_cdn_url())\n        else:\n            \"\"\"Otherwise, return a streaming response\"\"\"\n            return app.response_class(\n                file.object.as_stream(),\n                mimetype=file.content_type,\n                headers={\"Content-Disposition\": f\"attachment;filename={file.filename}\"},\n            )\n    except ObjectDoesNotExistError:\n        abort(404)\n</code></pre> <p>See full example here</p>"},{"location":"tutorial/setup-your-storage/","title":"Setup your storage","text":"<p>StorageManager is the class which takes care of managing the whole Storage environment for the application.</p>"},{"location":"tutorial/setup-your-storage/#terminology","title":"Terminology","text":"<p><code>Container:</code> represents a container which can contain multiple objects. You can think of it as a folder on a file system. Difference between container and a folder on file system is that containers cannot be nested. Some APIs and providers (e.g. AWS) refer to it as a Bucket.</p> <p><code>Object:</code>  represents an object or so-called BLOB. (SQLAlchemy-file will store each file as an object)</p> <p>For more information, follow Apache Libcloud Documentation</p>"},{"location":"tutorial/setup-your-storage/#add-storage","title":"Add Storage","text":"<p>Before adding a storage, the first thing you need is to setup an apache libcloud storage container.</p> LocalMinIOS3 <pre><code>import os\nfrom libcloud.storage.drivers.local import LocalStorageDriver\nfrom sqlalchemy_file.storage import StorageManager\n\nos.makedirs(\"./upload_dir/attachment\", 0o777, exist_ok=True) # Make sure the directory exist\nmy_container = LocalStorageDriver(\"./upload_dir\").get_container(\"attachment\")\nStorageManager.add_storage(\"default\", container)\n</code></pre> <pre><code>from libcloud.storage.types import Provider\nfrom libcloud.storage.types import ContainerAlreadyExistsError\nfrom libcloud.storage.providers import get_driver\n\ncls = get_driver(Provider.MINIO)\ndriver = cls(\"api key\", \"api secret key\", secure=False, host=\"127.0.0.1\", port=9000)\n\ntry:\n    driver.create_container(container_name=\"attachment\")\nexcept ContainerAlreadyExistsError:\n    pass\n\nmy_container = driver.get_container(container_name=\"attachment\")\n</code></pre> <pre><code>from libcloud.storage.providers import get_driver\nfrom libcloud.storage.types import Provider\n\ncls = get_driver(Provider.S3)\ndriver = cls(\"api key\", \"api secret key\")\n\nmy_container = driver.get_container(container_name=\"attachment\")\n</code></pre> <p>For more examples, see Apache Libcloud Storage Examples</p> <p>Then, you can easily add your container to the storage manager</p> <p>Example</p> <pre><code>from sqlalchemy_file.storage import StorageManager\n\nStorageManager.add_storage(\"default\", my_container)\n</code></pre>"},{"location":"tutorial/setup-your-storage/#using-multiple-storages","title":"Using Multiple Storages","text":"<p>Multiple storage can be used inside the same application, most common operations require the full file path, so you can use multiple storage without risk of collisions.</p> <pre><code>from libcloud.storage.drivers.local import LocalStorageDriver\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.orm import declarative_base\nfrom sqlalchemy_file.storage import StorageManager\nfrom sqlalchemy_file.types import FileField\n\nBase = declarative_base()\n\n\nclass Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content_first = Column(FileField(upload_storage=\"first\"))\n    content_second = Column(FileField(upload_storage=\"second\"))\n\n\nfirst_container = LocalStorageDriver(\"./storage\").get_container(\"first\")\nsecond_container = LocalStorageDriver(\"./storage\").get_container(\"second\")\n\nStorageManager.add_storage(\"first\", first_container)\nStorageManager.add_storage(\"second\", second_container)\n</code></pre>"},{"location":"tutorial/setup-your-storage/#switching-default-storage","title":"Switching Default Storage","text":"<p>Once you started uploading files to a storage, it is best to avoid configuring another storage to the same name. Doing that will probably break all the previously uploaded files and will cause confusion.</p> <p>If you want to switch to a different storage for saving your files just configure two storage giving the new storage an unique name and switch the default storage using the <code>StorageManager.set_default()</code> function.</p> <pre><code>from libcloud.storage.drivers.local import LocalStorageDriver\nfrom sqlalchemy_file.storage import StorageManager\n\nfirst_container = LocalStorageDriver(\"./storage\").get_container(\"first\")\nsecond_container = LocalStorageDriver(\"./storage\").get_container(\"second\")\n\nStorageManager.add_storage(\"first\", first_container)\nStorageManager.add_storage(\"second\", second_container)\n\nassert StorageManager.get_default() == \"first\"\n\nStorageManager.set_default(\"second\")\n\nassert StorageManager.get_default() == \"second\"\n</code></pre>"},{"location":"tutorial/using-files-in-models/","title":"Using files in models","text":"<p>Attaching files to models is as simple as declaring a field on the model itself.</p>"},{"location":"tutorial/using-files-in-models/#fields","title":"Fields","text":"<p>You can use two Column type in your model.</p>"},{"location":"tutorial/using-files-in-models/#filefield","title":"FileField","text":"<p>FileField is the main field, that can be used in your model to accept any files.</p> <p>Example</p> <pre><code>from sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\n\nfrom sqlalchemy_file import FileField\n\nBase = declarative_base()\n\nclass Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(FileField)\n</code></pre>"},{"location":"tutorial/using-files-in-models/#imagefield","title":"ImageField","text":"<p>Inherits all attributes and methods from FileField, but also validates that the uploaded file is a valid image.</p> <p>Note</p> <p>Using ImageField is like using  FileField with ImageValidator and ThumbnailGenerator</p> <p>Example</p> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy_file import ImageField\n\nBase = declarative_base()\n\n\nclass Book(Base):\n    __tablename__ = \"book\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    title = Column(String(100), unique=True)\n    cover = Column(ImageField(thumbnail_size=(128, 128)))\n</code></pre>"},{"location":"tutorial/using-files-in-models/#upload-file","title":"Upload File","text":"<p>Let's say you defined your model like this <pre><code>class Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(FileField)\n</code></pre> and configure your storage like this <pre><code>container = LocalStorageDriver(\"./upload_dir\").get_container(\"attachment\")\nStorageManager.add_storage(\"default\", container)\n</code></pre></p>"},{"location":"tutorial/using-files-in-models/#save-file-object","title":"Save file object","text":"<p>Whenever a supported object is assigned to a FileField or ImageField it will be converted to a File object. <pre><code>with Session(engine) as session:\n    session.add(Attachment(name=\"attachment1\", content=open(\"./example.txt\", \"rb\")))\n    session.add(Attachment(name=\"attachment2\", content=b\"Hello world\"))\n    session.add(Attachment(name=\"attachment3\", content=\"Hello world\"))\n    file = File(content=\"Hello World\", filename=\"hello.txt\", content_type=\"text/plain\")\n    session.add(Attachment(name=\"attachment4\", content=file))\n    session.commit()\n</code></pre> The file itself will be uploaded to your configured storage, and only the File information will be stored on the database as JSON.</p>"},{"location":"tutorial/using-files-in-models/#retrieve-file-object","title":"Retrieve file object","text":"<p>This is the same File object you will get back when reloading the models from database and the file itself is accessible through the <code>.file</code> property.</p> <p>Note</p> <p>Check the File documentation for all default attributes save into the database.</p> <pre><code>with Session(engine) as session:\n    attachment = session.execute(\n            select(Attachment).where(Attachment.name == \"attachment3\")\n        ).scalar_one()\n    assert attachment.content.saved # saved is True for saved file\n    assert attachment.content.file.read() == b\"Hello world\" # access file content\n    assert attachment.content[\"filename\"] is not None # `unnamed` when no filename are provided\n    assert attachment.content[\"file_id\"] is not None # uuid v4\n    assert attachment.content[\"upload_storage\"] == \"default\"\n    assert attachment.content[\"content_type\"] is not None\n    assert attachment.content[\"uploaded_at\"] is not None\n</code></pre>"},{"location":"tutorial/using-files-in-models/#save-additional-information","title":"Save additional information","text":"<p>It's important to note that File object inherit from python <code>dict</code>. Therefore, you can add additional information to your file object like a dict object. Just make sure to not use the default attributes used by File object internally.</p> <p>Example</p> <pre><code>content = File(open(\"./example.txt\", \"rb\"),custom_key1=\"custom_value1\", custom_key2=\"custom_value2\")\ncontent[\"custom_key3\"] = \"custom_value3\"\nattachment = Attachment(name=\"Dummy\", content=content)\n\nsession.add(attachment)\nsession.commit()\nsession.refresh(attachment)\n\nassert attachment.custom_key1 == \"custom_value1\"\nassert attachment.custom_key2 == \"custom_value2\"\nassert attachment[\"custom_key3\"] == \"custom_value3\"\n</code></pre> <p>Important</p> <p>File provides also attribute style access. You can access your keys as attributes.</p>"},{"location":"tutorial/using-files-in-models/#extra-headers","title":"Extra &amp; Headers","text":"<p><code>Apache-libcloud</code> allow you to store each object with some <code>extra</code> attributes or additional <code>headers</code>.</p> <p>They are two ways to add <code>extra</code> and <code>headers</code> with sqlalchemy-file</p> <ul> <li>on field declaration (shared by all associated files)</li> </ul> <pre><code>class Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(\n        FileField(\n            extra={\n                \"acl\": \"private\",\n                \"dummy_key\": \"dummy_value\",\n                \"meta_data\": {\"key1\": \"value1\", \"key2\": \"value2\"},\n            },\n            headers={\n                \"Access-Control-Allow-Origin\": \"http://test.com\",\n                \"Custom-Key\": \"xxxxxxx\",\n            },\n        )\n    )\n</code></pre> <ul> <li>in your File object</li> </ul> <p>Important</p> <p>When the Field has default <code>extra</code> attribute, it's overridden by File object <code>extra</code> attribute</p> <pre><code>with Session(engine) as session:\n    attachment = Attachment(\n            name=\"Public document\",\n            content=File(DummyFile(), extra={\"acl\": \"public-read\"}),\n        )\n    session.add(attachment)\n    session.commit()\n    session.refresh(attachment)\n\n    assert attachment.content.file.object.extra[\"acl\"] == \"public-read\"\n</code></pre>"},{"location":"tutorial/using-files-in-models/#metadata","title":"Metadata","text":"<p>Warning</p> <p>This attribute is now deprecated, migrate to extra</p> <p>SQLAlchemy-file store the uploaded file with some metadata. Only <code>filename</code> and <code>content_type</code> are sent by default, . You can complete with <code>metadata</code> key inside your File object.</p> <p>Example</p> <pre><code>with Session(engine) as session:\n    content = File(DummyFile(), metadata={\"key1\": \"val1\", \"key2\": \"val2\"})\n    attachment = Attachment(name=\"Additional metadata\", content=content)\n    session.add(attachment)\n    session.commit()\n    attachment = session.execute(\n        select(Attachment).where(Attachment.name == \"Additional metadata\")\n    ).scalar_one()\n    assert attachment.content.file.object.meta_data[\"key1\"] == \"val1\"\n    assert attachment.content.file.object.meta_data[\"key2\"] == \"val2\"\n</code></pre>"},{"location":"tutorial/using-files-in-models/#uploading-on-a-specific-storage","title":"Uploading on a Specific Storage","text":"<p>By default, all the files are uploaded on the default storage which is the first added storage. This can be changed by passing a <code>upload_storage</code> argument explicitly on field declaration:</p> <pre><code>from libcloud.storage.providers import get_driver\nfrom libcloud.storage.types import Provider\nfrom sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy_file import FileField\nfrom sqlalchemy_file.storage import StorageManager\n\nBase = declarative_base()\n# Amazon S3 Container\namazon_s3_container = get_driver(Provider.S3)(\n    \"api key\", \"api secret key\"\n).get_container(\"example\")\n\n# MinIO Container\nmin_io_container = get_driver(Provider.MINIO)(\n    \"api key\", \"api secret key\"\n).get_container(\"example\")\n\n# Configure Storage\nStorageManager.add_storage(\"amazon_s3_storage\", amazon_s3_container)\nStorageManager.add_storage(\"min_io_storage\", min_io_container)\n\n\nclass AttachmentS3(Base):\n    __tablename__ = \"attachment_s3\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(FileField(upload_storage=\"amazon_s3_storage\"))\n\n\nclass AttachmentMinIO(Base):\n    __tablename__ = \"attachment_min_io\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content_min_io = Column(FileField(upload_storage=\"min_io_storage\"))\n</code></pre>"},{"location":"tutorial/using-files-in-models/#validators","title":"Validators","text":"<p>File validators get executed just before saving the uploaded file.</p> <p>They can raise ValidationError when the uploaded files are not compliant with the validator conditions.</p> <p>Multiple validators can be chained together to validate one file.</p> <p>Validators can add additional properties to the file object. For example ImageValidator add <code>width</code> and <code>height</code> to the file object.</p> <p>SQLAlchemy-file has built-in validators to get started, but you can create your own validator by extending Validator base class.</p> <p>Built-in validators:</p> <ol> <li>SizeValidator : Validate file maximum size</li> <li>ContentTypeValidator: Validate file mimetype</li> <li>ImageValidator: Validate image</li> </ol> <p>Example</p> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nfrom sqlalchemy_file import FileField\nfrom sqlalchemy_file.validators import ContentTypeValidator, SizeValidator\n\nBase = declarative_base()\n\n\nclass Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(\n        FileField(\n            validators=[\n                SizeValidator(\"500k\"),\n                ContentTypeValidator([\"text/plain\", \"text/csv\"]),\n            ]\n        )\n    )\n</code></pre>"},{"location":"tutorial/using-files-in-models/#processors","title":"Processors","text":"<p>File processors get executed just after saving the uploaded file. They can be use to generate additional files and attach it to the column. For example, ThumbnailGenerator generate thumbnail from original image.</p> <p>Multiple processors can be chained together. They will be executed in order.</p> <p>Processors can add additional properties to the file object. For example ThumbnailGenerator add generated <code>thumbnail</code> file information into the file object.</p> <p>Example</p> <pre><code>from sqlalchemy import Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy_file import ImageField\nfrom sqlalchemy_file.processors import ThumbnailGenerator\n\nBase = declarative_base()\n\n\nclass Book(Base):\n    __tablename__ = \"book\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    title = Column(String(100), unique=True)\n    cover = Column(ImageField(processors=[ThumbnailGenerator()]))\n</code></pre>"},{"location":"tutorial/using-files-in-models/#multiple-files","title":"Multiple Files","text":"<p>The best way to handle multiple files, is to use SQLAlchemy relationships</p> <p>Example</p> <pre><code>from sqlalchemy import Column, ForeignKey, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy_file import FileField\n\nBase = declarative_base()\n\n\nclass Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    content = Column(FileField)\n\n    article_id = Column(Integer, ForeignKey(\"article.id\"))\n\n\nclass Article(Base):\n    __tablename__ = \"article\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    title = Column(String(100), unique=True)\n\n    attachments = relationship(Attachment, cascade=\"all, delete-orphan\")\n</code></pre> <p>However, if you want to save multiple files directly in your model, set <code>multiple=True</code> on field declaration:</p> <pre><code>import os\n\nfrom libcloud.storage.drivers.local import LocalStorageDriver\nfrom sqlalchemy import Column, Integer, String, create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy_file import File, FileField\nfrom sqlalchemy_file.storage import StorageManager\n\nBase = declarative_base()\n\n\nclass Attachment(Base):\n    __tablename__ = \"attachment\"\n\n    id = Column(Integer, autoincrement=True, primary_key=True)\n    name = Column(String(50), unique=True)\n    multiple_content = Column(FileField(multiple=True))\n\n\n# Configure Storage\nos.makedirs(\"./upload_dir/attachment\", 0o777, exist_ok=True)\ncontainer = LocalStorageDriver(\"./upload_dir\").get_container(\"attachment\")\nStorageManager.add_storage(\"default\", container)\n\n# Save your model\nengine = create_engine(\n    \"sqlite:///example.db\", connect_args={\"check_same_thread\": False}\n)\nBase.metadata.create_all(engine)\n\nwith Session(engine) as session:\n    session.add(\n        Attachment(\n            name=\"attachment1\",\n            multiple_content=[\n                \"from str\",\n                b\"from bytes\",\n                open(\"./example.txt\", \"rb\"),\n                File(\n                    content=\"Hello World\",\n                    filename=\"hello.txt\",\n                    content_type=\"text/plain\",\n                ),\n            ],\n        )\n    )\n    session.commit()\n</code></pre> <p>Validators and processors will be applied to each file, and the return models is a list of File object.</p>"},{"location":"tutorial/using-files-in-models/#session-awareness","title":"Session Awareness","text":"<p>Whenever an object is deleted or a rollback is performed the files uploaded during the unit of work or attached to the deleted objects are automatically deleted.</p>"}]}